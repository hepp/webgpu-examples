<html>
  <head>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
      integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
      crossorigin="anonymous"
      defer
    ></script>
  </head>

  <body>
    <canvas id="container" width="700px" height="450px"></canvas>

    <script id="shader-wgsl" type="x-shader-wgsl">
      struct Uniforms {
          modelViewProjectionMatrix : mat4x4<f32>,
      }
      @binding(0) @group(0) var<uniform> uniforms : Uniforms;

      struct VertexOutput {
          @builtin(position) Position : vec4<f32>,
          @location(0) fragUV : vec2<f32>,
          @location(1) fragPosition: vec4<f32>,
      }

      @vertex
      fn vert_main(
          @location(0) position : vec4<f32>,
          @location(1) uv : vec2<f32>
      ) -> VertexOutput {
          var output : VertexOutput;
          output.Position = uniforms.modelViewProjectionMatrix * position;
          output.fragUV = uv;
          output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));
          return output;
      }

      @fragment
      fn frag_main(
          @location(0) fragUV: vec2<f32>,
          @location(1) fragPosition: vec4<f32>
      ) -> @location(0) vec4<f32> {
          return fragPosition;
      }
    </script>
    <script>
      const init = async () => {
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();

        const canvas = document.getElementById('container');
        const context = canvas.getContext('webgpu');

        const devicePixelRatio = window.devicePixelRatio || 1;
        const presentationSize = [
          canvas.clientWidth * devicePixelRatio,
          canvas.clientHeight * devicePixelRatio,
        ];

        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device,
          size: presentationSize,
          format: presentationFormat,
          alphaMode: 'opaque',
        });

        const cubeVertexSize = 4 * 10;
        const cubePositionOffset = 0;

        const cubeColorOffset = 4 * 4;
        const cubeUVOffset = 4 * 8;
        const cubeVertexCount = 36;

        const cubeVertexArray = new Float32Array([
            1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
            -1, -1, 1, 1,  0, 0, 1, 1,  0, 1,
            -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,
            1, -1, -1, 1,  1, 0, 0, 1,  1, 0,
            1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
            -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,

            1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
            1, -1, 1, 1,   1, 0, 1, 1,  0, 1,
            1, -1, -1, 1,  1, 0, 0, 1,  0, 0,
            1, 1, -1, 1,   1, 1, 0, 1,  1, 0,
            1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
            1, -1, -1, 1,  1, 0, 0, 1,  0, 0,

            -1, 1, 1, 1,   0, 1, 1, 1,  1, 1,
            1, 1, 1, 1,    1, 1, 1, 1,  0, 1,
            1, 1, -1, 1,   1, 1, 0, 1,  0, 0,
            -1, 1, -1, 1,  0, 1, 0, 1,  1, 0,
            -1, 1, 1, 1,   0, 1, 1, 1,  1, 1,
            1, 1, -1, 1,   1, 1, 0, 1,  0, 0,

            -1, -1, 1, 1,  0, 0, 1, 1,  1, 1,
            -1, 1, 1, 1,   0, 1, 1, 1,  0, 1,
            -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
            -1, -1, -1, 1, 0, 0, 0, 1,  1, 0,
            -1, -1, 1, 1,  0, 0, 1, 1,  1, 1,
            -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,

            1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
            -1, 1, 1, 1,   0, 1, 1, 1,  0, 1,
            -1, -1, 1, 1,  0, 0, 1, 1,  0, 0,
            -1, -1, 1, 1,  0, 0, 1, 1,  0, 0,
            1, -1, 1, 1,   1, 0, 1, 1,  1, 0,
            1, 1, 1, 1,    1, 1, 1, 1,  1, 1,

            1, -1, -1, 1,  1, 0, 0, 1,  1, 1,
            -1, -1, -1, 1, 0, 0, 0, 1,  0, 1,
            -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
            1, 1, -1, 1,   1, 1, 0, 1,  1, 0,
            1, -1, -1, 1,  1, 0, 0, 1,  1, 1,
            -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
        ]);
        console.log('Vertices:', cubeVertexArray.length);

        const verticesBuffer = device.createBuffer({
          size: cubeVertexArray.byteLength,
          usage: GPUBufferUsage.VERTEX,
          mappedAtCreation: true,
        });

        new Float32Array(verticesBuffer.getMappedRange()).set(cubeVertexArray);
        verticesBuffer.unmap();

        const shaderModule = device.createShaderModule({
          code: document.getElementById('shader-wgsl').innerText,
        });

        const pipeline = device.createRenderPipeline({
          layout: 'auto',
          vertex: {
            module: shaderModule,
            entryPoint: 'vert_main',
            buffers: [
              {
                arrayStride: cubeVertexSize,
                attributes: [
                  {
                    shaderLocation: 0,
                    offset: cubePositionOffset,
                    format: 'float32x4',
                  },
                  {
                    shaderLocation: 1,
                    offset: cubeUVOffset,
                    format: 'float32x2',
                  },
                ],
              },
            ],
          },
          fragment: {
            module: shaderModule,
            entryPoint: 'frag_main',
            targets: [
              {
                format: presentationFormat,
              },
            ],
          },
          primitive: {
            topology: 'triangle-list',
            cullMode: 'back',
          },
          depthStencil: {
            depthWriteEnabled: true,
            depthCompare: 'less',
            format: 'depth24plus',
          },
        });

        const depthTexture = device.createTexture({
          size: presentationSize,
          format: 'depth24plus',
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });

        const matrixSize = 4 * 16; // 4x4 matrix
        const offset = 256; 
        const uniformBufferSize = offset + matrixSize;
        console.log('Uniform Buffer Size:', uniformBufferSize);

        const uniformBuffer = device.createBuffer({
          size: uniformBufferSize,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        const uniformBindGroup1 = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: uniformBuffer,
                offset: 0,
                size: matrixSize,
              },
            },
          ],
        });

        const uniformBindGroup2 = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: uniformBuffer,
                offset: offset,
                size: matrixSize,
              },
            },
          ],
        });

        const renderPassDescriptor = {
          colorAttachments: [
            {
              view: undefined,

              clearValue: { r: 0.5, g: 0.5, b: 0.5, a: 1.0 },
              loadOp: 'clear',
              storeOp: 'store',
            },
          ],
          depthStencilAttachment: {
            view: depthTexture.createView(),

            depthClearValue: 1.0,
            depthLoadOp: 'clear',
            depthStoreOp: 'store',
          },
        };

        const aspect = presentationSize[0] / presentationSize[1];
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, (2 * Math.PI) / 5, aspect, 1, 100.0);

        const modelMatrix1 = mat4.create();
        mat4.translate(modelMatrix1, modelMatrix1, vec3.fromValues(-2, 0, 0));
        const modelMatrix2 = mat4.create();
        mat4.translate(modelMatrix2, modelMatrix2, vec3.fromValues(2, 0, 0));
        const modelViewProjectionMatrix1 = mat4.create();
        const modelViewProjectionMatrix2 = mat4.create();
        const viewMatrix = mat4.create();
        mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -4.5));

        const tmpMat41 = mat4.create();
        const tmpMat42 = mat4.create();

        function updateTransformationMatrix() {
          const now = Date.now() / 1000;

          mat4.rotate(
            tmpMat41,
            modelMatrix1,
            1,
            vec3.fromValues(Math.sin(now), Math.cos(now), 0)
          );
          mat4.rotate(
            tmpMat42,
            modelMatrix2,
            1,
            vec3.fromValues(Math.cos(now), Math.sin(now), 0)
          );

          mat4.multiply(modelViewProjectionMatrix1, viewMatrix, tmpMat41);
          mat4.multiply(
            modelViewProjectionMatrix1,
            projectionMatrix,
            modelViewProjectionMatrix1
          );
          mat4.multiply(modelViewProjectionMatrix2, viewMatrix, tmpMat42);
          mat4.multiply(
            modelViewProjectionMatrix2,
            projectionMatrix,
            modelViewProjectionMatrix2
          );
        }

        function frame() {
          updateTransformationMatrix();
          device.queue.writeBuffer(
            uniformBuffer,
            0,
            modelViewProjectionMatrix1.buffer,
            modelViewProjectionMatrix1.byteOffset,
            modelViewProjectionMatrix1.byteLength
          );
          device.queue.writeBuffer(
            uniformBuffer,
            offset,
            modelViewProjectionMatrix2.buffer,
            modelViewProjectionMatrix2.byteOffset,
            modelViewProjectionMatrix2.byteLength
          );

          renderPassDescriptor.colorAttachments[0].view = context
            .getCurrentTexture()
            .createView();

          const commandEncoder = device.createCommandEncoder();
          const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
          passEncoder.setPipeline(pipeline);
          passEncoder.setVertexBuffer(0, verticesBuffer);

          passEncoder.setBindGroup(0, uniformBindGroup1);
          passEncoder.draw(cubeVertexCount, 1, 0, 0);

          passEncoder.setBindGroup(0, uniformBindGroup2);
          passEncoder.draw(cubeVertexCount, 1, 0, 0);

          passEncoder.end();
          device.queue.submit([commandEncoder.finish()]);

          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      };
      init();
    </script>
  </body>
</html>
