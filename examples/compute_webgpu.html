<html>
  <body>
    <h2 style="text-align: center; color: white">
      Results of GPU matrix calculations shown in log:
    </h2>

    <script id="shader-wgsl" type="x-shader-wgsl">
      struct Matrix {
          size : vec2<f32>,
          numbers: array<f32>,
        }

        @group(0) @binding(0) var<storage, read> firstMatrix : Matrix;
        @group(0) @binding(1) var<storage, read> secondMatrix : Matrix;
        @group(0) @binding(2) var<storage, read_write> resultMatrix : Matrix;

        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {
          // Guard against out-of-bounds work group sizes
          if (global_id.x >= u32(firstMatrix.size.x) || global_id.y >= u32(secondMatrix.size.y)) {
            return;
          }

          resultMatrix.size = vec2(firstMatrix.size.x, secondMatrix.size.y);

          let resultCell = vec2(global_id.x, global_id.y);
          var result = 0.0;
          for (var i = 0u; i < u32(firstMatrix.size.y); i = i + 1u) {
            let a = i + resultCell.x * u32(firstMatrix.size.y);
            let b = resultCell.y + i * u32(secondMatrix.size.y);
            result = result + firstMatrix.numbers[a] * secondMatrix.numbers[b];
          }

          let index = resultCell.y + resultCell.x * u32(secondMatrix.size.y);
          resultMatrix.numbers[index] = result;
        }
    </script>
    <script>
      const init = async () => {
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();

        const firstMatrix = new Float32Array([
            2 /* rows */ , 4 /* columns */ ,
            1, 2, 3, 4,
            5, 6, 7, 8
        ]);

        const gpuBufferFirstMatrix = device.createBuffer({
          mappedAtCreation: true,
          size: firstMatrix.byteLength,
          usage: GPUBufferUsage.STORAGE,
        });
        const arrayBufferFirstMatrix = gpuBufferFirstMatrix.getMappedRange();

        new Float32Array(arrayBufferFirstMatrix).set(firstMatrix);
        gpuBufferFirstMatrix.unmap();

        const secondMatrix = new Float32Array([
            4 /* rows */ , 2 /* columns */ ,
            1, 2,
            3, 4,
            5, 6,
            7, 8
        ]);

        const gpuBufferSecondMatrix = device.createBuffer({
          mappedAtCreation: true,
          size: secondMatrix.byteLength,
          usage: GPUBufferUsage.STORAGE,
        });

        const arrayBufferSecondMatrix = gpuBufferSecondMatrix.getMappedRange();
        new Float32Array(arrayBufferSecondMatrix).set(secondMatrix);
        gpuBufferSecondMatrix.unmap();

        const resultMatrixBufferSize =
          Float32Array.BYTES_PER_ELEMENT *
          (2 + firstMatrix[0] * secondMatrix[1]);
        const resultMatrixBuffer = device.createBuffer({
          size: resultMatrixBufferSize,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
        });

        const shaderModule = device.createShaderModule({
          code: document.getElementById('shader-wgsl').innerText,
        });

        const computePipeline = device.createComputePipeline({
          layout: 'auto',
          compute: {
            module: shaderModule,
            entryPoint: 'main',
          },
        });

        const bindGroup = device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0 /* index */),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: gpuBufferFirstMatrix,
              },
            },
            {
              binding: 1,
              resource: {
                buffer: gpuBufferSecondMatrix,
              },
            },
            {
              binding: 2,
              resource: {
                buffer: resultMatrixBuffer,
              },
            },
          ],
        });

        const commandEncoder = device.createCommandEncoder();

        const passEncoder = commandEncoder.beginComputePass();
        passEncoder.setPipeline(computePipeline);
        passEncoder.setBindGroup(0, bindGroup);
        const workgroupCountX = Math.ceil(firstMatrix[0] / 8);
        const workgroupCountY = Math.ceil(secondMatrix[1] / 8);
        passEncoder.dispatchWorkgroups(workgroupCountX, workgroupCountY);
        passEncoder.end();

        const gpuReadBuffer = device.createBuffer({
          size: resultMatrixBufferSize,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });

        // Encode commands for copying buffer to buffer.
        commandEncoder.copyBufferToBuffer(
          resultMatrixBuffer /* source buffer */,
          0 /* source offset */,
          gpuReadBuffer /* destination buffer */,
          0 /* destination offset */,
          resultMatrixBufferSize /* size */
        );

        const gpuCommands = commandEncoder.finish();
        device.queue.submit([gpuCommands]);

        await gpuReadBuffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = gpuReadBuffer.getMappedRange();
        console.log('-> Matrix 1:', firstMatrix.toString());
        console.log('-> Matrix 2:', secondMatrix.toString());
        console.log(
          '-> Result Matrix:',
          new Float32Array(arrayBuffer).toString()
        );
        console.log(
          'Learn more about this example: https://web.dev/gpu-compute/'
        );

        function frame() {
          requestAnimationFrame(frame);
        }

        // Include requestAnimationFrame to satisfy iframe error detection
        requestAnimationFrame(frame);
      };
      init();
    </script>
  </body>
</html>
